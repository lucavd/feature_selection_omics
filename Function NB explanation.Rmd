---
title: "Function explanation NB"
author: "Luca Vedovelli"
date: "`r Sys.Date()`"
output: html_document
---

## Negative binomial

Step 1: Function signature and default arguments

The sim_nb_data() function takes several arguments, including the sample size (n), the true effect size (beta), the number of genes (nGenes), the standard deviation of the random effects (re_sd), the standard deviation of the gene effects (gene_sd), the proportion of genes with a true effect (p0), and a binary variable indicating whether the sample should be split into two groups (two_group). The default values for these arguments are chosen to be reasonable starting points, but can be changed if desired.

Step 2: Generating mu_x

The mu_x variable is generated using an exponential distribution with rate parameter 1/10. This is done to create a distribution of values that is skewed towards lower values, which is a reasonable assumption for gene expression data (since many genes are not expressed at high levels). If this line is commented out, a normal distribution with mean 0 and standard deviation 1 is used instead.

Step 3: Generating x

The x matrix is generated by concatenating a column of ones (for the intercept) with a column of normally distributed values with mean mu_x. This creates a design matrix that can be used to fit a linear model to the data.

Step 4: Generating z

The z variable is generated either as a binary vector of 0s and 1s (if two_group is TRUE), or as a vector of normally distributed values (if two_group is FALSE). This variable is used to create an interaction effect between the treatment group and the gene expression values.

Step 5: Generating random effects

The b_0 and b_1 matrices are generated using the replicate() function, which creates nGenes replicates of normal distributions with mean 0 and standard deviation 1 (for b_0), or standard deviation re_sd (for b_1). The gene_f variable is generated using a normal distribution with mean 0 and standard deviation gene_sd. These variables represent the random effects in the simulated data, which can be used to model differences between individuals and differences between genes.

Step 6: Initializing mu and y

The mu and y matrices are initialized as copies of the b_0 matrix. These matrices will be used to store the mean expression levels and the simulated counts for each gene, respectively.

Step 7: Calculating n.h1

The n.h1 variable is calculated as round(nGenes*(1-p0)), which represents the number of genes that will have a true effect. This variable is used to determine how many genes should have a nonzero effect size (i.e. beta).

Step 8: Looping through genes

The for loop iterates through each column of b_0 (i.e. each gene) and calculates values for mu and y based on whether the gene has a true effect or not. If the current gene has a true effect (i.e. ii <= n.h1), then the effect size is set to beta plus a random gene effect and a random individual-specific effect. The mean mu is calculated as int + b_0[,ii] + rowSums(x) + (b_1[,ii] + beta + gene_f[ii])*(z*x[,2]), where `

The loop then goes through each column of b_0 (i.e., each gene) and applies a different linear model to simulate its expression levels. Specifically, if ii is greater than n.h1, the model assumes that the gene is not differentially expressed and only depends on the intercept and the covariate x. The expression levels for this gene are calculated as int + b_0[,ii] + rowSums(x), where int is the intercept value (int <- 1000), b_0[,ii] is the intercept value for the specific gene, and rowSums(x) is the sum of x across columns, which corresponds to the effect of the covariate x on the expression levels.

If ii is less than or equal to n.h1, the model assumes that the gene is differentially expressed and its expression levels depend on both x and z. In this case, the expression levels for this gene are calculated as int + b_0[,ii] + rowSums(x) + (b_1[,ii] + beta + gene_f[ii])*(z*x[,2]). This equation includes an additional term that represents the effect of z (i.e., the grouping variable) on the expression levels, which is the product of z and the second column of x (i.e., x[,2]), as well as the random effects b_1 and gene_f[ii]. The beta parameter controls the strength of the effect of z on the expression levels.

The expression levels are then checked to ensure that they are non-negative, since expression levels cannot be negative in reality. This is done using the ifelse function to set any negative values to 0.

Finally, the expression levels are simulated using the rnbinom function, which generates random numbers from a negative binomial distribution. The negative binomial distribution is commonly used to model count data, such as gene expression counts, where the variance exceeds the mean. The mu parameter of the negative binomial distribution is set to the corresponding mu[,ii] value calculated in step 9, and the size parameter is set to rexp(n), which generates random numbers from an exponential distribution with rate parameter 1/re_sd. The +1 term added to the rnbinom function is to avoid zero counts, since count data cannot be zero.

Finally, the function returns a list of the simulated data, including x (the covariate matrix), z (the grouping variable), y (the simulated expression counts), and indiv (an identifier for each individual)